"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[9399],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,n]of s)a[i]=n;return a}},6416:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>t});var n=a(641);const e={},l=(0,a(6262).A)(e,[["render",function(i,s){return(0,n.uX)(),(0,n.CE)("div",null,s[0]||(s[0]=[(0,n.Fv)('<h1 id="esp32上的串口输出" tabindex="-1"><a class="header-anchor" href="#esp32上的串口输出"><span>ESP32上的串口输出</span></a></h1><h3 id="了解串口-uart-usart" tabindex="-1"><a class="header-anchor" href="#了解串口-uart-usart"><span>了解串口（UART/USART）</span></a></h3><h4 id="串口通信协议实例" tabindex="-1"><a class="header-anchor" href="#串口通信协议实例"><span>串口通信协议实例</span></a></h4><p>串口通信协议是在计算机、微控制器或其他设备之间传输数据的一种方式。串口是指外设和处理器之间通过数据信号线、地线和控制线等，<strong>按位</strong>进行传输数据的一种通讯方式。尽管传输速度比并行传输低，但串口可以在<strong>使用一根线发送数据</strong>的同时<strong>用另一根线接收数据</strong>。 这种通信方式使用的数据线少，在远距离通信中可以节约通信成本。在Arduino项目中，串口通信非常常见也非常重要，可以用于设备间的数据传输、调试信息的输出，以及与计算机或其他串行设备的通信。</p><h4 id="串口通信基本概念" tabindex="-1"><a class="header-anchor" href="#串口通信基本概念"><span>串口通信基本概念</span></a></h4><p>串口通信使用<strong>TX</strong>（发送）和<strong>RX</strong>（接收）两个引脚来进行数据的发送和接收。Arduino和许多其他支持Arduino固件的板子都有内置的串行通信功能，可以通过USB接口与计算机通信，也可以使用数字引脚（如0和1）与其他设备进行串行通信。</p><h4 id="串口通信介绍" tabindex="-1"><a class="header-anchor" href="#串口通信介绍"><span>串口通信介绍</span></a></h4><p>串口通信协议定义了在串口上进行数据交换的规则和格式。常见的串口通信协议包括ASCII协议、Modbus协议、RS-232协议等。协议规定了数据的帧结构、数据格式、校验方式等，确保发送和接收双方按照相同的规则进行数据交换，从而实现数据的正确传输和解析。   串口通信是一位一位地传输，每传输一个字符总是以起始位开始，以停止位结束，字符之间没有固定的时间间隔要求。每一个字符的前面都有一位起始位（低电平），后面由 7 位数据位组成，接着是一位校验位，最后是停止位。停止位后面是不定长的空闲位，停止位和空闲位都规定为高电平。</p><figure><img src="https://wiki.lckfb.com/storage/images/zh-hans/coloreasyduino/beginner/project-practice/project-practice_20240827_050846.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>串口通信参数包括波特率（Baud Rate）、数据位（Data Bits）、校验位（Parity Bits）、停止位（Stop Bits）等。这些参数描述了传输数据的基本规格。例如，波特率定义了数据传输的速率，数据位确定每个数据字节中包含的位数，校验位用于数据的差错检测，停止位表示数据传输结束的标志等。</p><ul><li>波特率：衡量通信速度的参数，它表示每秒钟传送的 bit 的个数。</li><li>数据位：衡量通信中实际数据位的参数，表示一个信息包里包含的数据位的个数。</li><li>停止位：用于表示单个信息包的最后位，典型值为 1、1.5 和 2 位。由于数据是在传输线上传输的，每个设备都有自己的时钟，很有可能在通信过程中出现不同步，停止位不仅仅表示传输的结束，还能提供校正时钟同步的机会。停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率也越慢。</li><li>奇偶检验位：表示一种简单的检查错误的方式。</li></ul><h4 id="串口工作模式" tabindex="-1"><a class="header-anchor" href="#串口工作模式"><span>串口工作模式</span></a></h4><p>串口工作模式分为三种：单工、全双工模式和半双工模式。</p><ul><li>单工：在通信的任意时刻，信息只能由 A 传到 B，或B传到A；</li><li>半双工：在通信的任意时刻，信息即可由 A 传到 B，又能由 B 传到 A，但同时只能有一个方向上的传输存在；</li><li>全双工：在通信的任意时刻，通信线路上存在 A 到 B 和 B 到 A 的双向信号传输；</li></ul><h4 id="串口通信的作用及优势" tabindex="-1"><a class="header-anchor" href="#串口通信的作用及优势"><span>串口通信的作用及优势</span></a></h4><p>串口是计算机和外部设备之间最常见的通信接口之一，具有重要的作用和广泛的应用。在计算机领域，串口的重要性体现在以下几个方面：</p><ol><li>数据传输：串口是一种常用的数据传输接口。通过串口，计算机可以与各种外部设备进行数据交换和通信。无论是传感器、执行器、显示器、打印机还是其他外部设备，串口通信都可以实现数据的传输和控制。</li><li>远程控制和监控：串口通信被广泛应用于远程控制和监控领域。通过串口，计算机可以远程控制设备的动作，并实时监测设备的状态和数据信息。这在工业控制、自动化系统、远程监控等场景中具有重要的作用。</li><li>调试和故障排查：串口通信是调试和故障排查的重要工具。通过串口，计算机可以与嵌入式系统、单片机等进行通信，实时监控和调试程序，输出调试信息，进行错误定位和排查，并对系统进行状态监测和故障诊断。</li><li>硬件连接：串口可以作为计算机与各种外部设备之间的连接桥梁。通过串口，可以连接和控制各类外部设备，如传感器、执行器、外围设备等。串口能够提供稳定的数据传输和双向通信功能。</li><li>通信协议：串口通信协议是计算机与外部设备之间数据传输的规范和约定。通过定义不同的协议，可以实现不同设备之间的数据交互和通信。常见的串口通信协议有UART、RS-232、RS-485等。</li></ol><p>总之，串口对于计算机和外部设备之间的通信具有重要的作用。它是数据传输、远程控制和监控、调试和故障排查的关键工具，是计算机与外部设备连接和通信的桥梁。</p><h3 id="函数讲解" tabindex="-1"><a class="header-anchor" href="#函数讲解"><span>函数讲解</span></a></h3><p>在软件层面，Arduino固件提供了<code>Serial</code>库，用于实现串行通信。这个库提供了多种方法来发送和接收数据。</p><p><strong>初始化串口</strong></p><p>ESP32S3有三个串口，分别是Serial，Serial1, Serial2,其中Serial用作串口下载和调试，在串口充足的情况下应当优先使用Serial1和Serial2。 使用<code>Serial.begin(baudRate)</code>方法初始化串行通信，<code>baudRate</code>指定了数据传输的速率（比特率），例如9600、115200等。这个速率必须和接收方保持一致。</p><p>还有一个比较常用的是<code>Serial.begin(unsigned long baud, uint32_t config, int8_t rxPin, int8_t txPin)</code></p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> RX1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 12</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> TX1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 13</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  \tSerial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">115200</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 设置波特率为115200</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Serial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">460800</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, SERIAL_8N1, RX1, TX1);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>发送数据</strong></p><p>可以使用<code>Serial.print()</code>和<code>Serial.println()</code>发送数据。<code>print</code>方法发送数据但不添加换行符，而 <code>println</code>会在数据末尾添加换行符。</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">){</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Serial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 发送字符串并自动换行</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  \t\tSerial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Serial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;当前的i是&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i))</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  \t\tdelay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 每秒发送一次</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以使用<code>Serial.write(const uint8_t *buffer, size_t size)</code>来发送byte类型的数组</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">uint8_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> send_data[] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">0x</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">55</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">0x</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">55</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">0x</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">01</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">0x</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">12</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Serial1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">write</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(send_data, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(send_data));</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>接收数据</strong></p><p>使用<code>Serial.available()</code>检查是否有数据可读，如果此函数返回0，表示没有数据可读。如果有，<code>Serial.read()</code>可以用来读取一个字节的数据.</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> loop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Serial1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">available</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    char</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> received </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Serial</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">read</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 读取并存储一个字节的数据</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Serial1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">print</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Received: &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    Serial1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(received);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 显示接收到的数据</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而<code>Serial.readbytes()</code>则可以直接把读取到的数据存放到数组中</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ProcessOPiData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uint8_t</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> data</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">11</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">\tSerial2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">readBytes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(data, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(data));</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ......</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>高级读取</strong></p><ul><li><code>Serial.readString()</code>: 读取串口接收到的字符，直到遇到超时。这个方法依赖于<code>setTimeout()</code>设定的超时时间。</li><li><code>Serial.readStringUntil(terminator)</code>: 读取串口数据，直到遇到指定的终止字符或超时。</li><li><code>Serial.parseInt()</code>: 从串口读取数据并解析为<code>int</code>类型。这对于接收数字类型的数据非常方便。</li><li><code>Serial.parseFloat()</code>: 从串口读取数据并解析为<code>float</code>类型。适用于需要处理浮点数的情况。</li></ul><h2 id="串口使用示例" tabindex="-1"><a class="header-anchor" href="#串口使用示例"><span>串口使用示例</span></a></h2><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h3>',38)]))}]]),t=JSON.parse('{"path":"/posts/2024%E4%B8%80%E6%9C%9F%E5%9F%B9%E8%AE%AD/5.html","title":"ESP32上的串口输出","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-12-30T00:00:00.000Z","category":["培训","ESP32"],"tag":["ledc","PWM","pwm"],"order":5,"description":"ESP32上的串口输出 了解串口（UART/USART） 串口通信协议实例 串口通信协议是在计算机、微控制器或其他设备之间传输数据的一种方式。串口是指外设和处理器之间通过数据信号线、地线和控制线等，按位进行传输数据的一种通讯方式。尽管传输速度比并行传输低，但串口可以在使用一根线发送数据的同时用另一根线接收数据。 这种通信方式使用的数据线少，在远距离通信...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/2024%E4%B8%80%E6%9C%9F%E5%9F%B9%E8%AE%AD/5.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"ESP32上的串口输出"}],["meta",{"property":"og:description","content":"ESP32上的串口输出 了解串口（UART/USART） 串口通信协议实例 串口通信协议是在计算机、微控制器或其他设备之间传输数据的一种方式。串口是指外设和处理器之间通过数据信号线、地线和控制线等，按位进行传输数据的一种通讯方式。尽管传输速度比并行传输低，但串口可以在使用一根线发送数据的同时用另一根线接收数据。 这种通信方式使用的数据线少，在远距离通信..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://wiki.lckfb.com/storage/images/zh-hans/coloreasyduino/beginner/project-practice/project-practice_20240827_050846.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-16T05:11:17.000Z"}],["meta",{"property":"article:tag","content":"ledc"}],["meta",{"property":"article:tag","content":"PWM"}],["meta",{"property":"article:tag","content":"pwm"}],["meta",{"property":"article:published_time","content":"2024-12-30T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-16T05:11:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ESP32上的串口输出\\",\\"image\\":[\\"https://wiki.lckfb.com/storage/images/zh-hans/coloreasyduino/beginner/project-practice/project-practice_20240827_050846.png\\"],\\"datePublished\\":\\"2024-12-30T00:00:00.000Z\\",\\"dateModified\\":\\"2025-01-16T05:11:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"王明照\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":3,"title":"了解串口（UART/USART）","slug":"了解串口-uart-usart","link":"#了解串口-uart-usart","children":[]},{"level":3,"title":"函数讲解","slug":"函数讲解","link":"#函数讲解","children":[]},{"level":2,"title":"串口使用示例","slug":"串口使用示例","link":"#串口使用示例","children":[{"level":3,"title":"","slug":"","link":"#","children":[]}]}],"git":{"createdTime":1735650944000,"updatedTime":1737004277000,"contributors":[{"name":"graphwmz","email":"ouyanglingle@outlook.com","commits":2}]},"readingTime":{"minutes":6.93,"words":2079},"filePathRelative":"posts/2024一期培训/5.md","localizedDate":"2024年12月30日","excerpt":"\\n<h3>了解串口（UART/USART）</h3>\\n<h4>串口通信协议实例</h4>\\n<p>串口通信协议是在计算机、微控制器或其他设备之间传输数据的一种方式。串口是指外设和处理器之间通过数据信号线、地线和控制线等，<strong>按位</strong>进行传输数据的一种通讯方式。尽管传输速度比并行传输低，但串口可以在<strong>使用一根线发送数据</strong>的同时<strong>用另一根线接收数据</strong>。 这种通信方式使用的数据线少，在远距离通信中可以节约通信成本。在Arduino项目中，串口通信非常常见也非常重要，可以用于设备间的数据传输、调试信息的输出，以及与计算机或其他串行设备的通信。</p>","autoDesc":true}')}}]);