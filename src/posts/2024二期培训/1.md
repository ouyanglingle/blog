---
icon: pen-to-square
date: 2024-12-29
category:
  - 培训
  - ESP32
tag:
  - ESP32S3
  - ESP32
  - ESP
order: 1  # 这是侧边栏的顺序
---

# 外部中断与定时器

## 1 外部中断

### 1.1 什么是中断

- 在单片机系统中，中断是一种机制。它允许单片机在执行正常程序的过程中，暂停当前的任务，转而去处理其它更为紧急或者有更高优先级的事件。当这个紧急事件处理完毕后，单片机又能够回到原来被中断的地方，继续执行之前的程序，就好像被打断的工作又重新开始一样。
- 例如，想象你正在房间里看书（这就相当于单片机在执行主程序），突然电话铃响了（这就是一个中断事件）。你放下书本去接电话（处理中断），接完电话后，你又能回到刚才看书的地方继续阅读（返回主程序）。

### 1.2 外部中断介绍

- 外部中断是指由单片机外部设备或信号触发的中断。它提供了一种让单片机能够及时响应外部事件的方式，使单片机可以和外部世界进行有效的交互。

- 外部中断是硬件中断的一种，它由微控制器外部的事件引发。微控制器的某些引脚被设计为对特定事件的发生做出响应，例如按钮的按压、传感器的信号改变等。这些指定的引脚通常被称为“外部中断引脚”。

- 之前做按键实验时，现有代码靠loop循环持续检测 IO 口来读取 GPIO 口输入。若后续添加大量代码，轮询到按键检测部分耗时久、效率低。比如特定场合下，按键可能 1 天才按一次，持续检测浪费大量时间。为解决该问题，引入外部中断概念，即仅在按键按下产生中断时，才执行相关功能。这大幅节省 CPU 资源，所以中断在实际项目中应用广泛 。

- ESP32S3 的外部中断有上升沿触发、下降沿触发、低电平触发、高电平触发模式（可以在Arduino.h中查找到）。上升沿和下降沿触发如下：

  ![上升下降沿.jpg](https://github.com/ouyanglingle/blog/blob/main/src/.vuepress/public/assets/images/%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E6%B2%BF.jpg?raw=true)

### 1.3 外部中断的作用和优势

实时响应外部事件	提高系统的效率	实现多任务处理的协同	灵活的触发方式适应多种设备

### 1.4 使用外部中断流程

#### 1.4.1配置引脚

因为外部中断实际上还是读取引脚的状态，所以需要将引脚设置为输入或启用上拉电阻输入模式；在 `setup()` 函数中，使用 `pinMode()` 函数将引脚配置为输入引脚:

`pinMode(pin, INPUT);`或`pinMode(pin, INPUT_PULLUP);`

#### 1.4.2将引脚绑定中断服务程序并设置触发中断方式

```cpp
int IntPin = 0;

void ISR()
{
    //省略代码...
}

void setup()
{
	// 配置中断引脚为GPIO5，假设外部中断回调函数为 ISR(), 中断下降沿触发
	attachInterrupt(digitalPinToInterrupt(IntPin), ISR, FALLING);
    // 或者
    attachInterrupt(IntPin, ISR, FALLING);
}
```

**注意**：`attachInterrupt()`函数只适用于 `digitalPinToInterrupt()` 所支持的GPIO引脚，而不是所有的GPIO引脚都能用于外部中断。此外，在中断服务函数进行中断处理时，一定要避免使用占用 CPU 大量时间的操作（例如延时函数），以确保中断响应速度和精度。

`attachInterrupt()` 函数有两种参数传递方式，可以传递函数指针或者函数名。如果是函数名，可以直接传递函数名，不需要加上括号。如果函数名被加上了括号，那就相当于调用该函数，传递的则是函数的返回值。如果使用函数指针，那么需要在函数名前加上`&`符号。

#### 1.4.3处理中断事件

a. **尽量保证中断程序内容少**

b. **避免**在中断处理函数中**使用** **阻塞函数**（如 `delay()`），使用非阻塞的延迟方法来处理需要延迟的操作（`micros() 函数`），以保证中断的正常执行和系统的稳定性。这是因为 `delay()` 函数会阻塞整个系统，包括中断的正常执行。当中断触发时，处理函数应该尽快执行完毕，以确保**及时响应**并避免中断积压；

c. **与主程序共享的变量要加上 volatile 关键字；**

d. 在 Arduino 中使用中断时，应尽量避免在中断处理函数中使用 `Serial` 串口对象的打印函数。当在中断处理函数中使用 `Serial` 打印函数时，会导致以下问题：

- 时间延迟：`Serial` 打印函数通常是比较耗时的操作，它会**阻塞中断**的执行时间，导致中断响应的延迟。这可能会导致在中断期间丢失其他重要的中断事件或导致系统不稳定。
- 缓冲区溢出：`Serial` 对象在内部使用一个缓冲区来存储要发送的数据。如果在中断处理函数中频繁调用 `Serial` 打印函数，可能会导致缓冲区溢出，造成数据丢失或不可预测的行为。

为了避免这些问题，建议在中断处理函数中尽量**避免使用 `Serial` 打印函数**。如果需要在中断处理函数中输出调试信息，可以使用其他方式，如**设置标志位**，在主循环中检查标志位并进行打印。

#### 1.4.4示例代码与现象



```cpp
#include <Arduino.h>
// 将按钮一端连接到GPIO4引脚，另一端连接到GND，和板子共地
// 将LED正极接GPIO15，负极接地
#define Button 4
#define LED 15

void buttonISR()
{
    static bool state = false;
    digitalWrite(LED, state = !state);
}
void setup()
{
    Serial.begin(115200);
    pinMode(Button, INPUT_PULLUP);
    pinMode(LED, OUTPUT);
    attachInterrupt(Button, buttonISR, FALLING);
    delay(2000);
}

void loop() {
    delay(1000);
}
```



```cpp
##include <Arduino.h>
#define BUTTON 4
#define LED 15

//LED状态
bool led_flag = false;
//按键状态（中断回调函数与主程序共享的变量要加上 volatile 关键字）
volatile bool flag = false;

//中断回调函数
void ISR()
{
  flag = true;
}

void setup()
{
  //设置KEY引脚（0） 为上拉输入模式
  pinMode(BUTTON, INPUT_PULLUP);

  //设置LED引脚（48） 为输出模式
  pinMode(LED, OUTPUT);

  // 配置中断引脚为GPIO0，外部中断回调函数为 ISR(), 中断下降沿触发
  attachInterrupt(digitalPinToInterrupt(BUTTON), ISR, FALLING);
}

void loop()
{
  //当按键按下时会产生一个下降沿，进入回调函数 ISR()，而ISR()中只是将flag = true
  //故当flag == true 时，说明按键按下
  if ( flag == true )
  {
    //延时200毫秒
    delay(200);
    //LED状态取反
    digitalWrite(LED, led_flag=!led_flag);

    // 重置中断标志位
    flag = false;

  }
}
```



## 2. 定时器
